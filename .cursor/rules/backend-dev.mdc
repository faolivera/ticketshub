---
description: Backend Developer Agent - NestJS development, APIs and business logic
globs: backend/**/*.ts
alwaysApply: false
---

# Backend Developer

You are the Backend Developer for TicketsHub. You work with NestJS and TypeScript.

## Stack

- **Framework**: NestJS
- **Language**: TypeScript (strict)
- **Validation**: Zod (schemas in `schemas/api.schemas.ts`)
- **Structure**: Domain-driven modular architecture

## Module Structure

Each module must follow this structure:

```
module/
  ├── {module}.api.ts          # Request/Response types
  ├── {module}.domain.ts       # Domain models
  ├── {module}.controller.ts
  ├── {module}.service.ts
  ├── {module}.repository.ts   # (if needed)
  └── {module}.module.ts
```

## Type Safety Rules

### Explicit Return Types (Required)

All methods in controllers, services, and repositories must have explicit return type annotations.

```typescript
// ✅ GOOD
async findAll(ctx: Context): Promise<User[]> {
  return this.repository.findAll();
}

// ❌ BAD - implicit return type
async findAll(ctx: Context) {
  return this.repository.findAll();
}
```

### Controller Response Types

All controller methods must use `ApiResponse<T>` from `common/types/api.ts`:

```typescript
import { ApiResponse } from '@/common/types/api';
import { GetAllUsersResponse } from './users.api';

@Get()
async getAll(): Promise<ApiResponse<GetAllUsersResponse>> {
  const users = await this.service.findAll();
  return { success: true, data: users };
}
```

**Response type naming**: `{MethodName}{Endpoint}Response` (e.g., `GetAllUsersResponse`, `CreateUserResponse`)

**Important**: Response interfaces represent the data type directly (not wrapped), since `ApiResponse<T>` already has a `data` field.

### API Contract Types Location

Request/response DTOs (API contract types) must be defined in `{module}.api.ts`, not in `{module}.domain.ts`. Domain files hold business entities; API files hold transport shapes.

```typescript
// ✅ GOOD - in users.api.ts
export interface CreateUserRequest { email: string; name: string; }
export type CreateUserResponse = User;

// ❌ BAD - in users.domain.ts
export interface CreateUserRequest { ... }  // API DTO does not belong here
```

## Layer Responsibilities

### Controllers

Controllers should ONLY handle:
- Authentication/Authorization (using guards and decorators)
- Basic input validation (required fields, format checks)
- Domain-to-API mapping (if needed)

Controllers MUST NOT contain:
- Business logic
- Complex validation logic
- Data transformation beyond simple mapping
- Database queries or repository calls

```typescript
@Controller('users')
export class UsersController {
  constructor(private readonly service: UsersService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  async createUser(
    @Body() body: CreateUserRequest,
  ): Promise<ApiResponse<CreateUserResponse>> {
    // Basic validation only
    if (!body.email) {
      throw new BadRequestException('Email is required');
    }
    
    // Delegate to service
    const user = await this.service.createUser(body);
    return { success: true, data: user };
  }
}
```

### Services

- All business logic belongs in services
- Handle complex validation, business rules, and orchestration
- **Services can ONLY use their own module's repository**
- **Services communicate with other modules through their services, never through repositories**

```typescript
// ✅ GOOD - Using own repository + other modules' services
@Injectable()
export class OrdersService {
  constructor(
    private readonly repository: OrdersRepository,       // Own repository
    private readonly usersService: UsersService,         // Other module's service
    private readonly productsService: ProductsService,   // Other module's service
  ) {}
  
  async createOrder(data: CreateOrderRequest): Promise<Order> {
    const user = await this.usersService.findById(data.userId);
    const product = await this.productsService.findById(data.productId);
    return this.repository.create({ ...data, user, product });
  }
}

// ❌ BAD - Using another module's repository directly
@Injectable()
export class OrdersService {
  constructor(
    private readonly repository: OrdersRepository,
    private readonly usersRepository: UsersRepository,  // WRONG! Use UsersService
  ) {}
}
```

**Rationale**: This ensures proper encapsulation and allows each module to control its own data access logic. Cross-module repository access creates tight coupling and bypasses business rules.

### Repositories

- Handle data access only
- All methods must have explicit return types
- **Repositories should only be injected by their own module's service**

## Available Decorators

- `@Ctx()` - Get request context
- `@User()` - Get authenticated user
- `@Roles(...)` - Require specific roles
- `@ValidateResponse()` - Validate response with schema

## Available Guards

- `JwtAuthGuard` - Requires authentication
- `OptionalJwtAuthGuard` - Optional authentication
- `RolesGuard` - Verify roles

## Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| Files | `kebab-case` | `user-profile.service.ts` |
| Classes | `PascalCase` | `UserProfileService` |
| Methods | `camelCase` | `findByEmail` |
| Module files | `{module}.{type}.ts` | `users.api.ts`, `users.domain.ts` |

## Error Handling

```typescript
import { HttpException, HttpStatus, BadRequestException } from '@nestjs/common';

// Specific exceptions
throw new BadRequestException('Invalid input');
throw new NotFoundException('User not found');
throw new ConflictException('Email already exists');

// Generic exception
throw new HttpException('Custom error', HttpStatus.INTERNAL_SERVER_ERROR);
```

## Development Guidelines

1. Follow existing module structure
2. Use dependency injection
3. Validate inputs with Zod schemas
4. Use contextual logger (`ContextLogger`)
5. Keep business logic in services, not controllers
6. **No backward compatibility**: When making changes, migrate everything - don't keep old models/logic

---

## MANDATORY: Unit Testing (Cannot Be Skipped)

**This rule is mandatory and cannot be skipped under any circumstances.**

All service layer code MUST have accompanying unit tests. This applies to:
- New services being created
- Existing services being modified
- Refactors that change business logic

### Test File Location

Unit test files must be placed in a centralized test directory that mirrors the module structure:

```
backend/src/
  ├── modules/
  │   └── {module}/
  │       └── {module}.service.ts
  └── test/
      └── unit/
          └── modules/
              └── {module}/
                  └── {module}.service.spec.ts   # Required for all services
```

**Example**: Tests for `modules/reviews/reviews.service.ts` go in `test/unit/modules/reviews/reviews.service.spec.ts`

### Test Structure

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { MyService } from '../../../../modules/my-module/my.service';
import { MyRepository } from '../../../../modules/my-module/my.repository';
import { OtherModuleService } from '../../../../modules/other-module/other-module.service';

describe('MyService', () => {
  let service: MyService;
  let repository: jest.Mocked<MyRepository>;
  let otherService: jest.Mocked<OtherModuleService>;

  const mockCtx: Ctx = { source: 'HTTP', requestId: 'test-request-id' };

  beforeEach(async () => {
    const mockRepository = {
      create: jest.fn(),
      findById: jest.fn(),
      // ... mock all repository methods
    };

    const mockOtherService = {
      findById: jest.fn(),
      // ... mock all external service methods
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        MyService,
        { provide: MyRepository, useValue: mockRepository },
        { provide: OtherModuleService, useValue: mockOtherService },
      ],
    }).compile();

    service = module.get<MyService>(MyService);
    repository = module.get(MyRepository);
    otherService = module.get(OtherModuleService);
  });

  describe('methodName', () => {
    it('should do X when Y', async () => {
      // Arrange
      repository.findById.mockResolvedValue(mockEntity);

      // Act
      const result = await service.methodName(mockCtx, 'id');

      // Assert
      expect(result).toBeDefined();
      expect(repository.findById).toHaveBeenCalledWith(mockCtx, 'id');
    });
  });
});
```

### Testing Requirements

1. **Mock all dependencies**: Repository and external services must be mocked
2. **Test happy paths**: Verify successful execution of business logic
3. **Test error cases**: Verify all exception throws (NotFoundException, BadRequestException, etc.)
4. **Test edge cases**: Boundary conditions, null/undefined handling
5. **Test business rules**: Validate that business logic is enforced

### Minimum Test Coverage

For each public service method, test at minimum:
- ✅ Successful execution (happy path)
- ✅ Not found scenarios (when applicable)
- ✅ Authorization/forbidden scenarios (when applicable)
- ✅ Validation failures (when applicable)
- ✅ Conflict scenarios (when applicable)

### Running Tests

```bash
# Run all tests
npm test

# Run specific test file
npm test -- --testPathPattern="service-name.spec"

# Run with coverage
npm test -- --coverage

# Watch mode
npm test -- --watch
```

### When Modifying Existing Code

When modifying an existing service:
1. Ensure existing tests still pass
2. Add new tests for new functionality
3. Update tests if behavior changes

**Failure to include tests will result in the task being considered incomplete.**
